(defmacro while (condition &body body)
  `(loop while ,condition
         do (progn ,@body)))

(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number)
          never (zerop (mod number fac)))))

(defun reduce-to-field-value (field-order number-to-reduce)
  (let* ((reduced (mod number-to-reduce field-order))
         (opposite (- reduced field-order)))
    (if (< (abs opposite) reduced)
        opposite reduced)))

(defun get-correct-input (&optional (option nil))
  (let ((value nil))
    (cond ((eql option 'modulo)
           (format t "Input a prime ~s: " option) (setq value (read))
           (while (not (and (integerp value) (primep value)))
             (format t "Try inputting an integer prime number: ")
             (setq value (read))) value)
          ((or (eql option 'a-coefficient) (eql option 'b-coefficient))
           (format t "Input ~s of the elliptic curve: " option) (setq value (read))
           (while (not (integerp value))
             (format t "Try inputting an integer number: ")
             (setq value (read))) value)
          (t (format t "You are not supposed to see that. Something went wrong.~%")))))

(defun elliptic-curve-equation (modulo a-coef b-coef x)
  (mod (+ (* x x x) (* a-coef x) b-coef) modulo))

(defun generate-elliptic-curve-points (modulo a-coef b-coef)
  (let* ((points nil) (half-modulo (/ (1- modulo) 2))
         (xs (mapcar #'(lambda (x) (list (elliptic-curve-equation modulo a-coef b-coef x) x))
                     (loop for num from (- half-modulo) upto half-modulo collect num))))
    (dotimes (y (1+ half-modulo))
      (let ((y-value (mod (* y y ) modulo)))
        (dolist (value-and-x xs)
          (if (eql y-value (car value-and-x))
              (let ((x (cadr value-and-x)))
                (cond ((zerop y) (setq points (cons (cons (gensym) (list x y)) points)))
                      (t (progn
                           (setq points (cons (cons (gensym) (list x    y))  points))
                           (setq points (cons (cons (gensym) (list x (- y))) points))))))))))
    points))

(defun make-indentation (num)
  (dotimes (iter num)
    (format t " ")))

(defun add-curve-points (P-point Q-point modulo a-coef)
  (let ((x-P (car P-point)) (y-P (cadr P-point))
        (x-Q (car Q-point)) (y-Q (cadr Q-point))
        (x-R nil) (y-R nil))
    (cond ((or (and (eql x-P 'INFTY) (eql x-Q 'INFTY))
               (and (eql x-P x-Q) (zerop (mod (+ y-P y-Q) modulo)))
               (and (eql x-P x-Q) (eql y-P y-Q) (eql y-P 0))) 'INFTY)
          ((eql x-P 'INFTY) Q-point)
          ((eql x-Q 'INFTY) P-point)
          ((not (eql x-P x-Q))
           (let* ((numer (mod (- y-Q y-P) modulo)) (denom (mod (- x-Q x-P) modulo))
                  (numer-sq (mod (* numer numer) modulo)) (denom-sq (mod (* denom denom) modulo))
                  (fraction (/ numer denom)))
             (setq x-R (mod (- (/ numer-sq denom-sq) (+ x-P x-Q)) modulo))
             (setq y-R (mod (+ (- y-P) (* fraction (- x-P x-R))) modulo))
             (list (/ (mod (numerator x-R) modulo) (mod (denominator x-R) modulo))
                   (/ (mod (numerator y-R) modulo) (mod (denominator y-R) modulo)))))
          ((and (eql x-P x-Q) (eql y-P y-Q))
           (let* ((numer (mod (+ (* 3 x-P x-P) a-coef) modulo)) (denom (mod (* 2 y-P) modulo))
                  (numer-sq (mod (* numer numer) modulo)) (denom-sq (mod (* denom denom) modulo))
                  (fraction (/ numer denom)))
             (setq x-R (mod (- (/ numer-sq denom-sq) (* 2 x-P)) modulo))
             (setq y-R (mod (+ (- y-P) (* fraction (- x-P x-R))) modulo))
             (list (/ (mod (numerator x-R) modulo) (mod (denominator x-R) modulo))
                   (/ (mod (numerator y-R) modulo) (mod (denominator y-R) modulo)))))
          (t (list 0 0)))))

(defun find-inverse (elt modulo)
  (let ((elt-inverse nil))
    (dotimes (iter modulo)
      (if (eql (mod (* elt iter) modulo) 1)
          (setq elt-inverse iter)))
    elt-inverse))

(defun find-mapping (point el-curve-points modulo)
  (cond ((eql point 'INFTY) (caar el-curve-points))
        (t (let* ((marker nil) (x (car point)) (y (cadr point))
                  (x-numer (numerator x)) (x-denom (denominator x)) (y-numer (numerator y)) (y-denom (denominator y)))
             (cond ((and (eql x-denom 1) (eql y-denom 1))
                    (dolist (iter-point el-curve-points)
                      (if (and (eql x-numer (cadr iter-point)) (eql y-numer (caddr iter-point)))
                          (setq marker (car iter-point)))) marker)
                   (t (let* ((x-denom-inverse (max 1 (find-inverse x-denom modulo)))
                             (y-denom-inverse (max 1 (find-inverse y-denom modulo)))
                             (new-x (mod (* x-numer x-denom-inverse) modulo))
                             (new-y (mod (* y-numer y-denom-inverse) modulo)))
                        (dolist (iter-point el-curve-points)
                          (if (and (eql new-x (cadr iter-point)) (eql new-y (caddr iter-point)))
                              (setq marker (car iter-point)))) marker)))))))

(defun reduce-point (point modulo)
  (cond ((eql point 'INFTY) 'INFTY)
        (t
         (let* ((x (car point)) (y (cadr point))
                (x-denom-inverse (max 1 (find-inverse (denominator x) modulo)))
                (y-denom-inverse (max 1 (find-inverse (denominator y) modulo))))
           (list (mod (* (numerator x) x-denom-inverse) modulo) (mod (* (numerator y) y-denom-inverse) modulo))))))

(defun generate-subgroup (point el-curve-points modulo a-coef)
  (let ((subgroup nil) (current-point point))
    (cond ((eql (car point) 'INFTY) (list (find-mapping 'INFTY el-curve-points modulo)))
          (t (while (not (eql current-point 'INFTY))
               (setq subgroup (cons current-point subgroup))
               (setq current-point (reduce-point (add-curve-points point current-point modulo a-coef) modulo)))))
    (setq subgroup (cons 'INFTY subgroup))
    (mapcar #'(lambda (subgroup-point) (find-mapping subgroup-point el-curve-points modulo)) subgroup)))

(defun generate-table (el-curve-points modulo a-coef)
  (format t "These are the points of the elliptic curve in the format: (name, x, y).~%")
  (format t "Point 'INFTY gets mapped into the symbol ~s.~%"  (caar el-curve-points))
  (dolist (point (cdr el-curve-points))
    (format t "Point (~d, ~d) gets mapped into the symbol ~s.~%"
            (cadr point) (caddr point) (car point)))
  (format t "~%")
  (make-indentation (+ (length (string (caar el-curve-points))) 3))
  (dolist (point el-curve-points)
    (format t "~s " (car point)))
  (let ((curve-order (length el-curve-points)))
    (dotimes (i curve-order)
      (let ((P-point (nth i el-curve-points)))
        (format t "~%~s " (car (nth i el-curve-points)))
        (dotimes (j curve-order)
          (let ((Q-point (nth j el-curve-points)))
            (format t "~s " (find-mapping (add-curve-points (cdr P-point) (cdr Q-point)
                                                            modulo a-coef)
                                          el-curve-points modulo))))))
    (format t "~%")
    (dolist (point el-curve-points)
      (let ((point-subgroup (reverse (generate-subgroup (cdr point) el-curve-points modulo a-coef))))
        (format t "~%Point ~s generates following subgroup of length ~d: ~{~a~^, ~}."
                (car point) (length point-subgroup) point-subgroup)))))

(defun get-input ()
  (let* ((modulo (get-correct-input 'modulo))
         (a-coef (reduce-to-field-value modulo (get-correct-input 'a-coefficient)))
         (b-coef (reduce-to-field-value modulo (get-correct-input 'b-coefficient)))
         (discrim (mod (+ (* 4 (expt a-coef 3)) (* 27 (expt b-coef 2))) modulo)))
    (cond ((zerop discrim) (format t "It is not an elliptic curve, since discriminant is zero.~%"))
          (t (let ((el-curve-points (cons (cons (gensym) (list 'INFTY))
                                          (generate-elliptic-curve-points modulo a-coef b-coef))))
               (format t "The order of the curve is ~d.~%" (length el-curve-points))
               (generate-table (cons (car el-curve-points)
                                     (mapcar #'(lambda (point) (list (car point)
                                                                     (mod (cadr point) modulo)
                                                                     (mod (caddr point) modulo)))
                                             (cdr el-curve-points))) modulo a-coef))))))

(defun main ()
  (get-input))
